/*
 *                        sc68 - config file
 *            Copyright (C) 2001-2009 Ben(jamin) Gerard
 *           <benjihan -4t- users.sourceforge -d0t- net>
 *
 * This  program is  free  software: you  can  redistribute it  and/or
 * modify  it under the  terms of  the GNU  General Public  License as
 * published by the Free Software  Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT  ANY  WARRANTY;  without   even  the  implied  warranty  of
 * MERCHANTABILITY or  FITNESS FOR A PARTICULAR PURPOSE.   See the GNU
 * General Public License for more details.
 *
 * You should have  received a copy of the  GNU General Public License
 * along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * $Id$
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_IO68_CONFIG_OPTION68_H
# include "io68/config_option68.h"
#else
# include "io68/default_option68.h"
#endif

#include "conf68.h"

/* file68 headers */
#include <sc68/error68.h>
#include <sc68/file68.h>
#include <sc68/url68.h>
#include <sc68/string68.h>
#include <sc68/debugmsg68.h>
#include <sc68/alloc68.h>

/* standard headers */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#ifndef DEBUG_CONFIG68_O
# define DEBUG_CONFIG68_O 0
#endif
static int config68_feature = debugmsg68_DEFAULT;

typedef union {
  int i;          /**< Used with CONFIG68_INT fields.     */
  const char * s; /**< Used with CONFIG68_STR fields.  */
} config68_value_t;

typedef struct _config68_field_s config68_field_t;

typedef struct
{
  const char * name;      /**< name of the entry.         */
  config68_type_t type;   /**< Type of this config entry. */
  const char * comment;   /**< Comment.                   */
  config68_value_t min;   /**< Minimum value allowed.     */
  config68_value_t max;   /**< Maximum value allowed.     */
  config68_value_t def;   /**< Default value the entry.   */
  config68_value_t val;   /**< Value for the entry.       */
} config68_entry_t;

struct _config68_s {
  int saved;    /**< True if config has been saved. */
  int size;     /**< Number of entries allocated.   */
  int n;        /**< Number of entries in used.     */

  /** Config entry table.
   * @warning Must be at the end of the struct.
   */
  config68_entry_t entries[1];
};


/* Defines for the config default values. */
#define AMIGA_BLEND      0x5000     /* Amiga default blending factor. */
#define	DEFAULT_TIME	 (3*60)     /* Track default time in second.  */
#define FORCE_TRACK      1          /* 0:no forced track              */
#define SKIP_TIME	 4          /* Skip music time in sec.        */
#define MAX_TIME        (24*60*60)  /* 1 day should be enought.       */
#define DEFAULT_SEEKSPD 0x0F00      /* << 8 */
#define MAX_SEEKSPD     0x1F00

static const config68_entry_t conftab[] = {
  {
    "version", CONFIG68_INT,
    "major*100+minor",
    {0}, {10000}, {PACKAGE_VERNUM}
  },
  {
    "sampling_rate", CONFIG68_INT,
    "sampling rate in Hz",
    {SAMPLING_RATE_MIN},{SAMPLING_RATE_MAX},{SAMPLING_RATE_DEF}
  },
  {
    "amiga_blend", CONFIG68_INT,
    "Amiga left/right voices blending factor",
    {0},{65535},{AMIGA_BLEND}
  },

  {
    "stf_emul", CONFIG68_INT,
    "STF/YM-2149 emulator (0:default 1:classic 2:BLEP)",
    {0},{2},{0}
  },
  {
    "ste_emul", CONFIG68_INT,
    "STE/MicroWire/LMC emulator (0:default 1:classic)",
    {0},{1},{0}
  },

  {
    "amiga_emul", CONFIG68_INT,
    "Amiga/Paula emulator (0:default 1:plain 2:linear-interp)",
    {0},{1},{0}
  },

  {
    "force_track", CONFIG68_INT,
    "override default track (0:OFF)",
    {0}, {99}, {FORCE_TRACK}
  },
  {
    "force_loop", CONFIG68_INT,
    "override default loop (-1:OFF 0:Infinite)",
    {-1}, {100}, {-1}
  },
  {
    "skip_time", CONFIG68_INT,
    "skip track less than given seconds (0:OFF)",
    {0}, {MAX_TIME}, {SKIP_TIME}
  },
  {
    "default_time", CONFIG68_INT,
    "default time in second if unknown",
    {0}, {MAX_TIME}, {DEFAULT_TIME}
  },
  {
    "seek_speed", CONFIG68_INT,
    "seek speed factor * 256 (0:OFF)",
    {0}, {MAX_SEEKSPD}, {DEFAULT_SEEKSPD}
  },
  {
    "total_time", CONFIG68_INT,
    "total playing time since first launch",
    {0}, {0}, {0}
  },
  {
    "total_ms", CONFIG68_INT,
    "total_time adjustment",
    {0}, {999}, {0}
  },
  {
    "music_path", CONFIG68_STR,
    "local sc68 music path",
    {0}, {0}, {0}
  },
  {
    "remote_on", CONFIG68_INT,
    "Enable sc68 remote access (using curl)",
    {0}, {1}, {1}
  },
  {
    "remote_music_path", CONFIG68_STR,
    "remote sc68 music path",
    {0}, {0}, {0}
  }
};

static const int nconfig = sizeof(conftab) / sizeof(conftab[0]);

static const char config_header[] =
"# -*- conf-mode -*-\n"
"#\n"
"# sc68 config file generated by " PACKAGE_STRING "\n"
"#\n"
"# " PACKAGE_URL "\n"
"#\n"
"# You can edit this file. If you remove it, sc68 will generate\n"
"# a new one at start-up with default values, but you will lost your\n"
"# total playing time. To avoid it, you should either save its value\n"
"# or delete all lines you want to be resetted.\n"
"# - *int* : integer values; \"C\" number format (e.g.0xFE0120).\n"
"# - *str* : String values; quoted with (\"); must not contain (\").\n"
"#\n";

static int is_symbol_char(int c)
{
  return
    (c>='0' && c<='9')
    || (c>='a' && c<='z')
    || (c>='A' && c<='Z')
    || c=='_'
    || c=='.';
}

static int digit(int c, unsigned int base)
{
  int n = -1;
  if (c <= '9') {
    n = c - '0';
  } else if (c <= 'Z') {
    n = c - 'A' + 10;
  } else if (c <= 'z'){
    n = c - 'a' + 10;
  }
  if ((unsigned int)n < base) {
    return n;
  }
  return -1;
}

#ifdef HAVE_STRTOL
# define mystrtoul strtol
#else

/** $$$ Need this function for dcplaya version. */
static long mystrtoul(const char * s,
		      char * * end,
		      unsigned int base)
{
  const char * start = s;
  unsigned long v = 0;
  int neg = 0, c;

  /* Skip starting spaces. */
  for (c = *s; (c == ' ' || c == 9 || c == 10 || c == 13); c = *++s)
    ;

  /* Get optionnal sign. */
  /* $$$ ben : Does not make sens with unsigned value ! */
  if (c == '-' || c == '+') {
    neg = (c == '-');
    c = *++s;
  }

  /* Get the base. */
  if (!base) {
    /* Assume default base is 10 */
    base = 10;

    /* Could be either octal(8) or hexidecimal(16) */
    if (c == '0') {
      base = 8;
      c = *++s;
      if (c == 'x' || c == 'X') {
	base = 16;
	c = *++s;
      }
    }
  } else if (base == 16 && c == '0') {
    /* Hexa mode must skip "0x" sequence */
    c = *++s;
    if (c == 'x' || c == 'X') {
      c = *++s;
    }
  }

  c = digit(c,base);
  if (c < 0) {
    s = start;
  } else {
    do {
      v = v * base + c;
      c = digit(*++s,base);
    } while (c >= 0);
  }

  if (end) {
    *end = (char *)s;
  }

  return neg ? -(signed long)v : v;
}

#endif

static int config_set_int(config68_t * conf, config68_entry_t *e, int v)
{
  int m,M;

  if (e->type != CONFIG68_INT) {
    debugmsg68(config68_feature,
	       "conf: set int name='%s' bad type (%d)\n", e->name, e->type);
    return -1;
  }
  m = e->min.i;
  M = e->max.i;

  debugmsg68(config68_feature,
	     "conf: set int name='%s' [%d..%d] cur:%d req:%d \n",
	     e->name, m, M, e->val.i, v);

  if (m != M) {
    if (m==0 && M == 1) {
      v = !!v;
    } else if (v < m) {
      v = m;
    } else if (v > M) {
      v = M;
    }
  }

  if (v != e->val.i) {
    conf->saved = 0;
    e->val.i = v;
    debugmsg68(config68_feature,
	       "conf: set int name='%s' [%d..%d] new:%d\n",
	       e->name, m, M, e->val.i);
  }
  return 0;
}

static int config_set_str(config68_t * conf, config68_entry_t *e,
			  const char * s)
{
  int err = 0;
  int m,M;

  if (e->type != CONFIG68_STR) {
    return -1;
  }

  m = e->min.i;
  M = e->max.i;
  if (m != M) {
    int v = s ? strlen(s) : 0;
    if (v < m || v > M) {
      s = 0;
      err = -1;
    }
  }

  if (!s) {
    if (e->val.s) {
      free68((void*)e->val.s);
      e->val.s = 0;
      conf->saved = 0;
    }
  } else if (!e->val.s || strcmp(s,e->val.s)) {
    free68((void*)e->val.s);
    e->val.s = strdup68(s);
    err = -!e->val.s;
    conf->saved = 0;
  }

  return err;
}


/* Check config values and correct invalid ones
 */
int config68_valid(config68_t * conf)
{
  int err = 0;
  int i;

  if (!conf) {
    return -1;
  }

  for (i=0; i < conf->n; i++) {
    config68_entry_t *e = conf->entries+i;
    switch (e->type) {
    case CONFIG68_INT:
      err |= config_set_int(conf, e, e->val.i);
      break;
    case CONFIG68_STR:
      err |= config_set_str(conf, e, e->val.s);
      break;
    default:
      err = -1;
    }
  }

  return -!!err;
}

int config68_get_idx(const config68_t * conf, const char * name)
{
  if (!conf) {
    return -1;
  }
  if (name) {
    int i;
    for (i=0; i<conf->n; i++) {
      if (!strcmp68(name,conf->entries[i].name)) {
	return i;
      }
    }
  }
  return -1;
}

config68_type_t config68_range(const config68_t * conf, int idx,
                                   int * min, int * max, int * def)
{
  config68_type_t type = CONFIG68_ERR;
  int vmin = 0 , vmax = 0, vdef = 0;

  if (conf && idx >= 0 && idx < conf->n) {
    type = conf->entries[idx].type;
    vmin = conf->entries[idx].min.i;
    vmax = conf->entries[idx].max.i;
    vdef = conf->entries[idx].def.i;
  }
  if (min) *min = vmin;
  if (max) *max = vmax;
  if (def) *def = vdef;
  return type;
}

config68_type_t config68_get(const config68_t * conf,
				 int * v,
				 const char ** name)
{
  int idx;
  config68_type_t type = CONFIG68_ERR;

  if (conf) {
    idx = v ? *v : -1;
    if (idx == -1 && name) {
      idx = config68_get_idx(conf, *name);
    }
    if (idx >= 0 && idx < conf->n) {
      switch (type = conf->entries[idx].type) {
      case CONFIG68_INT:
	if (v) *v = conf->entries[idx].val.i;
	break;
    
      case CONFIG68_STR:
	if (name) *name = conf->entries[idx].val.s
		    ? conf->entries[idx].val.s
		    : conf->entries[idx].def.s;
	break;

      default:
	type = CONFIG68_ERR;
	break;
      }
    }
  }
  return type;
}

config68_type_t config68_set(config68_t * conf,
				 int idx,
				 const char * name,
				 int v,
				 const char * s)
{
  config68_type_t type = CONFIG68_ERR;
  if (conf) {
    if (name) {
      idx = config68_get_idx(conf, name);
    }
    if (idx >= 0 && idx < conf->n) {
      switch (type = conf->entries[idx].type) {
      case CONFIG68_INT:
	config_set_int(conf, conf->entries+idx, v);
	break;
	
      case CONFIG68_STR:
	if (!config_set_str(conf, conf->entries+idx, s)) {
	  break;
	}
      default:
	type = CONFIG68_ERR;
	break;
      }
    }
  }
  return type;
}



static int save_config_entry(istream68_t * os, const config68_entry_t * e)
{
  int err = 0;
  char tmp[64];

  err |= istream68_puts(os, "\n# ") < 0;
  err |= istream68_puts(os, e->comment) < 0;

  switch (e->type) {
  case CONFIG68_INT:
    sprintf(tmp, "; *int* [%d..%d]", e->min.i, e->max.i);
    err |= istream68_puts(os, tmp) < 0;
    sprintf(tmp, " (%d)\n", e->def.i);
    err |= istream68_puts(os, tmp) < 0;
    break;

  case CONFIG68_STR:
    err |= istream68_puts(os, "; *str* (\"") < 0;
    err |= istream68_puts(os, e->def.s) < 0;
    err |= istream68_puts(os, "\")\n") < 0;
    break;

  default:
    istream68_puts(os, e->name);
    istream68_puts(os, ": invalid type\n");
    return -1;
  }

  switch (e->type) {
  case CONFIG68_INT:
    err |= istream68_puts(os, e->name) < 0;
    err |= istream68_putc(os, '=') < 0;
    sprintf(tmp, "%d", e->val.i);
    err |= istream68_puts(os, tmp) < 0;
    debugmsg68(config68_feature,"conf_save:[%s]=%d (int)\n",e->name, e->val.i);
    break;

  case CONFIG68_STR: {
    const char * s = e->val.s ? e->val.s : e->def.s;
    if (!s) {
      err |= istream68_putc(os, '#') < 0;
    }
    err |= istream68_puts(os, e->name) < 0;
    err |= istream68_putc(os, '=') < 0;
    err |= istream68_putc(os, '"') < 0;
    err |= istream68_puts(os, s) < 0;
    err |= istream68_putc(os, '"') < 0;
    debugmsg68(config68_feature,"conf_save:[%s]='%s' (str)\n",e->name, s);
  } break;

  default:
    break;
  }
  err |= istream68_putc(os, '\n') < 0;
  return err;
}

int config68_save(config68_t * conf)
{
  int i,err;
  istream68_t * os=0; 
  const int sizeof_config_hd = sizeof(config_header)-1; /* Remove '\0' */

  debugmsg68(config68_feature,"config68_save(%p) {\n", conf);

  if (!conf) {
    err = error68(0,"config68_save: <nul> pointer");
    /* err = debugmsg68(config68_feature,"config68_save: <nul> pointer"); */
    goto error;
  }
  os = url68_stream_create("RSC68://config", 2);

  err = istream68_open(os);
  if (err) {
    debugmsg68(config68_feature,"config68_save: open failed\n");
  }

  if (!err) {
    err =
      - (istream68_write(os, config_header, sizeof_config_hd)
	 != sizeof_config_hd);

    if (err) {
      debugmsg68(config68_feature,"config68_save: write header failed\n");
    }
  }	 
  for (i=0; !err && i < conf->n; ++i) {
    err = save_config_entry(os, conf->entries+i);
  }

 error:
  istream68_close(os);
  istream68_destroy(os);

  debugmsg68(config68_feature, "} config68_save => [%s]\n",strok68(err));
  return err;
}


/* Load config from file
 */
int config68_load(config68_t * conf)
{
  istream68_t * is = 0; 
  char s[1024], * word;
  int err;
  config68_type_t type;

  debugmsg68(config68_feature, "conf: load %p {\n",conf);

  err = config68_default(conf);
  if (err) {
    goto error;
  }

  is = url68_stream_create("RSC68://config", 1);
  err = istream68_open(is);
  if (err) {
    goto error;
  }
  debugmsg68(config68_feature, "conf: filename='%s'\n",
	     istream68_filename(is));

  for(;;) {
    char * name;
    int i, len, c = 0, idx;

    len = istream68_gets(is, s, sizeof(s));
    if (len == -1) {
      err = -1;
      break;
    }
    if (len == 0) {
      break;
    }

    i = 0;

    /* Skip space */
    while (i < len && (c=s[i++], (c == ' ' || c == 9)))
      ;

    if (!is_symbol_char(c)) {
      continue;
    }

    /* Get symbol name. */
    name = s+i-1;
    while (i < len && is_symbol_char(c = s[i++]))
      ;
    s[i-1] = 0;

    debugmsg68(config68_feature,"conf: load get key name='%s\n", name);

    /* Skip space */
    while (i < len && (c == ' ' || c == 9)) {
      c=s[i++];
    }

    /* Must have '=' */
    if (c != '=') {
      continue;
    }
    c=s[i++];
    /* Skip space */
    while (i < len && (c == ' ' || c == 9)) {
      c=s[i++];
    }

    if (c == '"') {
      type = CONFIG68_STR;
      word = s + i;
      debugmsg68(config68_feature,
		 "conf: load name='%s' looks like a string(%d)\n", name, type);
    } else if (c == '-' || digit(c, 10) != -1) {
      type = CONFIG68_INT;
      word = s + i - 1;
      debugmsg68(config68_feature,
		 "conf: load name='%s' looks like an int(%d)\n", name, type);
    } else {
      debugmsg68(config68_feature,
		 "conf: load name='%s' looks like nothing valid\n", name);
      continue;
    }
      debugmsg68(config68_feature,
		 "conf: load name='%s' not parsed value='%s'\n", name, word);

    idx = config68_get_idx(conf, name);
    if (idx < 0) {
      /* Create this config entry */
      debugmsg68(config68_feature, "conf: load name='%s' unknown\n", name);
      continue;
    }
    if (conf->entries[idx].type != type) {
      debugmsg68(config68_feature, "conf: load name='%s' types differ\n", name);
      continue;
    }

    switch (type) {
    case CONFIG68_INT:
      config_set_int(conf, conf->entries+idx, mystrtoul(word, 0, 0));
      debugmsg68(config68_feature, "conf: load name='%s'=<int>%d\n",
		 conf->entries[idx].name, conf->entries[idx].val.i);
      break;
    case CONFIG68_STR:
      while (i < len && (c=s[i++], c && c != '"'))
	;
      s[i-1] = 0;
      config_set_str(conf, conf->entries+idx, word);
      debugmsg68(config68_feature, "conf_load:[%s]='%s'\n",
		 conf->entries[idx].name, conf->entries[idx].val.s);
    default:
      break;
    }
  }
  if (!err) {
    err = config68_valid(conf);
  }

 error:
  istream68_destroy(is);
  debugmsg68(config68_feature, "} config68_load => [%s]\n",strok68(err));
  return err;
}

/* Fill config struct with default values.
 */
int config68_default(config68_t * conf)
{
  int i;

  if(!conf) {
    return -1;
  }
  for (i=0; i < conf->n; i++) {
    config68_entry_t * e = conf->entries+i;
    switch (e->type) {
    case CONFIG68_INT:
      e->val.i = e->def.i;
      break;
    case CONFIG68_STR:
      free68((void*)e->val.s);
      e->val.s = 0;
    default:
      break;
    }
  }
  conf->saved = 0;
  return config68_valid(conf);
}

config68_t * config68_create(int size)
{
  config68_t * c;
  int i,j;

  debugmsg68(config68_feature, "config68_create(size=%d) {\n",size);

  if (size < nconfig) {
    size = nconfig;
  }
  c = alloc68(sizeof(*c)-sizeof(c->entries)+sizeof(*c->entries)*size);
  if (c) {
    c->size = size;
    c->saved = 0;
    for (j=i=0; i<nconfig; ++i) {
      c->entries[j] = conftab[i];
      switch(c->entries[j].type) {
      case CONFIG68_INT:
	config_set_int(c, c->entries+j, c->entries[j].def.i);
	++j;
	break;

      case CONFIG68_STR:
	c->entries[j].val.s = 0;
	c->entries[j].def.s = 0;
	config_set_str(c, c->entries+j, 0);
	++j;
	break;

      default:
	break;
      }
    }
    c->n = j;
  }
  debugmsg68(config68_feature, "} config68_create => [%s]\n",strok68(!c));

  return c;
}

void config68_destroy(config68_t * c)
{
  debugmsg68(config68_feature, "config68_destroy(%p) {\n",c);
  if (c) {
    int i;

    for (i=0; i<c->n; ++i) {
      if (c->entries[i].type == CONFIG68_STR) {
	free68((void*)c->entries[i].val.s);
      }
    }
    free68(c);
  }
  debugmsg68(config68_feature, "} config68_destroy\n");
}

int config68_init(void)
{
  config68_feature = debugmsg68_feature("conf","config file", DEBUG_CONFIG68_O);
  return 0;
}

void config68_shutdown()
{
  debugmsg68_feature_free(config68_feature);
  config68_feature = debugmsg68_DEFAULT;
}
